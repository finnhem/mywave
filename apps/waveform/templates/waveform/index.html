<!DOCTYPE html>
<html>
<head>
    <title>Waveform Viewer</title>
    <script>
        // Global variables for cursor state
        let globalStartTime = 0;
        let globalEndTime = 0;
        let globalCursorTime = 0;
        let globalCanvases = [];
        let selectedSignal = null;

        function findTransitionPoints(data) {
            const transitions = [];
            // Always include start time
            transitions.push(data[0].time);
            
            // Add points where value changes
            for (let i = 0; i < data.length - 1; i++) {
                if (data[i].value !== data[i+1].value) {
                    transitions.push(data[i+1].time);
                }
            }
            return transitions;
        }

        function findCurrentTransitionIndex(transitions, cursorTime) {
            const EPSILON = 0.000001;
            // Binary search to find the closest transition
            let left = 0;
            let right = transitions.length - 1;
            
            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                if (Math.abs(transitions[mid] - cursorTime) < EPSILON) {
                    return mid;
                }
                if (transitions[mid] < cursorTime) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            return left - 1; // Return the index of the transition just before cursor
        }

        function selectSignal(signalName, nameDiv, waveformCanvas) {
            // Deselect previously selected signal
            if (selectedSignal) {
                selectedSignal.nameDiv.classList.remove('selected');
                selectedSignal.canvas.classList.remove('selected');
            }

            // Select new signal
            if (selectedSignal?.nameDiv === nameDiv) {
                // Clicking the same signal deselects it
                selectedSignal = null;
            } else {
                const transitions = findTransitionPoints(waveformCanvas.signalData);
                selectedSignal = {
                    name: signalName,
                    nameDiv: nameDiv,
                    canvas: waveformCanvas,
                    transitions: transitions,
                    currentIndex: findCurrentTransitionIndex(transitions, globalCursorTime)
                };
                nameDiv.classList.add('selected');
                waveformCanvas.classList.add('selected');
            }
        }

        function drawCursor(canvas, cursorX) {
            const ctx = canvas.getContext('2d');
            const height = canvas.height;
            
            // Draw cursor line without redrawing the entire canvas
            ctx.save();
            // Use composite operation to ensure cursor is visible
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(cursorX, 0);
            ctx.lineTo(cursorX, height);
            ctx.stroke();
            ctx.restore();
        }

        function clearAndRedraw(canvas) {
            if (canvas.id === 'timeline') {
                drawTimeline(canvas, globalStartTime, globalEndTime, true);
            } else {
                const signalData = canvas.signalData;
                if (signalData) {
                    drawWaveform(canvas, signalData, true);
                }
            }
        }

        function updateCursor(cursorX) {
            // Calculate cursor time based on position
            const width = document.querySelector('canvas').width;
            const timeRange = globalEndTime - globalStartTime;
            // Round to 6 decimal places to avoid floating point precision issues
            globalCursorTime = Math.round((globalStartTime + (cursorX / width) * timeRange) * 1000000) / 1000000;
            
            // Redraw all canvases and cursors
            globalCanvases.forEach(canvas => {
                clearAndRedraw(canvas);
                drawCursor(canvas, cursorX);
            });
            
            // Update cursor time display
            const cursorTimeDiv = document.getElementById('cursor-time');
            cursorTimeDiv.textContent = `Cursor Time: ${globalCursorTime}`;
        }

        function handleCanvasClick(event) {
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            updateCursor(x);
        }

        function drawWaveform(canvas, data, skipCursor = false) {
            // Store signal data for redrawing
            canvas.signalData = data;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            if (!data || data.length === 0) return;
            
            // Find time range
            const startTime = data[0].time;
            const endTime = data[data.length - 1].time;
            const timeRange = endTime - startTime;
            
            // Set up drawing style
            ctx.strokeStyle = canvas.classList.contains('selected') ? '#0066cc' : 'black';
            ctx.lineWidth = canvas.classList.contains('selected') ? 3 : 2;
            ctx.beginPath();
            
            // Draw waveform
            let lastX = 0;
            let lastY = height/2;
            
            data.forEach((point, index) => {
                // Scale x coordinate to canvas width
                const x = ((point.time - startTime) / timeRange) * width;
                
                // Determine y coordinate based on value
                let y;
                if (point.value === '1' || point.value === 'b1') {
                    y = 10;  // High level
                } else if (point.value === '0' || point.value === 'b0') {
                    y = height - 10;  // Low level
                } else {
                    y = height/2;  // Unknown/undefined level
                }
                
                if (index === 0) {
                    // Move to first point
                    ctx.moveTo(x, y);
                } else {
                    // Draw vertical transition if value changed
                    if (y !== lastY) {
                        ctx.lineTo(x, lastY);
                        ctx.lineTo(x, y);
                    }
                    // Draw horizontal line
                    ctx.lineTo(x, y);
                }
                
                lastX = x;
                lastY = y;
            });
            
            // Draw final horizontal line to end of canvas
            ctx.lineTo(width, lastY);
            
            // Render the path
            ctx.stroke();

            // Add canvas to global list if not already present
            if (!globalCanvases.includes(canvas)) {
                globalCanvases.push(canvas);
                canvas.addEventListener('click', handleCanvasClick);
            }

            // Draw initial cursor if needed
            if (!skipCursor && globalCursorTime !== undefined) {
                const cursorX = ((globalCursorTime - startTime) / timeRange) * width;
                drawCursor(canvas, cursorX);
            }
        }

        function drawTimeline(canvas, startTime, endTime, skipCursor = false) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw main horizontal line
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, height/2);
            ctx.lineTo(width, height/2);
            ctx.stroke();
            
            // Draw time markers
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            
            const timeRange = endTime - startTime;
            const numMarkers = 10;
            for (let i = 0; i <= numMarkers; i++) {
                const x = (i / numMarkers) * width;
                const time = startTime + (i / numMarkers) * timeRange;
                
                // Draw marker line
                ctx.beginPath();
                ctx.moveTo(x, height/2 - 5);
                ctx.lineTo(x, height/2 + 5);
                ctx.stroke();
                
                // Draw time label
                ctx.fillText(time.toString(), x, height - 2);
            }

            // Add canvas to global list if not already present
            if (!globalCanvases.includes(canvas)) {
                globalCanvases.push(canvas);
                canvas.addEventListener('click', handleCanvasClick);
            }

            // Draw cursor if needed
            if (!skipCursor && globalCursorTime !== undefined) {
                const cursorX = ((globalCursorTime - startTime) / timeRange) * width;
                drawCursor(canvas, cursorX);
            }
        }

        function uploadVCD() {
            const formData = new FormData(document.getElementById('upload-form'));
            const statusDiv = document.getElementById('status');
            const signalsDiv = document.getElementById('signals');
            
            // Reset global state
            globalCanvases = [];
            globalCursorTime = 0;
            
            statusDiv.textContent = 'Uploading...';
            signalsDiv.innerHTML = `
                <div id="cursor-time">Cursor Time: 0</div>
                <div id="cursor-controls">
                    <button onclick="moveCursorToStart()">⏮ Start</button>
                    <button onclick="moveToPreviousTransition()">◀ Prev</button>
                    <button onclick="moveToNextTransition()">Next ▶</button>
                    <button onclick="moveCursorToEnd()">End ⏭</button>
                </div>
                <div class="header">
                    <div>Signals</div>
                    <div class="waveform-header">
                        <canvas id="timeline" width="800" height="30"></canvas>
                    </div>
                </div>
            `;
            
            fetch('', {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                }
            })
            .then(response => response.json())
            .then(data => {
                console.log('Received response:', data);
                statusDiv.textContent = data.message;
                if (data.success && data.signals) {
                    console.log('Processing signals:', data.signals);
                    if (data.signals.length === 0) {
                        signalsDiv.innerHTML = '<div>No signals found in the VCD file</div>';
                    } else {
                        // Keep the header and add signals
                        const header = signalsDiv.querySelector('.header');
                        const cursorTimeDiv = signalsDiv.querySelector('#cursor-time');
                        const cursorControlsDiv = signalsDiv.querySelector('#cursor-controls');
                        signalsDiv.innerHTML = '';
                        signalsDiv.appendChild(cursorTimeDiv);
                        signalsDiv.appendChild(cursorControlsDiv);
                        signalsDiv.appendChild(header);
                        
                        // Set global time range
                        if (data.signals[0].data.length > 0) {
                            globalStartTime = data.signals[0].data[0].time;
                            globalEndTime = data.signals[0].data[data.signals[0].data.length - 1].time;
                            const timelineCanvas = document.getElementById('timeline');
                            drawTimeline(timelineCanvas, globalStartTime, globalEndTime);
                        }
                        
                        data.signals.forEach(signal => {
                            console.log('Adding signal:', signal.name);
                            const row = document.createElement('div');
                            row.className = 'row';
                            
                            // Create signal name div
                            const nameDiv = document.createElement('div');
                            nameDiv.textContent = signal.name;
                            nameDiv.className = 'signal-name';
                            
                            // Create canvas for waveform
                            const waveformDiv = document.createElement('div');
                            const canvas = document.createElement('canvas');
                            canvas.width = 800;
                            canvas.height = 40;
                            waveformDiv.appendChild(canvas);
                            
                            // Add click handlers for selection
                            nameDiv.addEventListener('click', () => selectSignal(signal.name, nameDiv, canvas));
                            
                            row.appendChild(nameDiv);
                            row.appendChild(waveformDiv);
                            signalsDiv.appendChild(row);
                            
                            // Draw the waveform
                            drawWaveform(canvas, signal.data);
                        });

                        // Draw initial cursor at time 0
                        updateCursor(0);
                    }
                } else {
                    console.log('No signals in response or parsing failed');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                statusDiv.textContent = 'Error uploading file: ' + error;
            });
            
            return false;
        }

        function moveCursorToStart() {
            updateCursor(0);
        }

        function moveCursorToEnd() {
            const width = document.querySelector('canvas').width;
            updateCursor(width);
        }

        function moveToPreviousTransition() {
            if (!selectedSignal) return;
            
            const transitions = selectedSignal.transitions;
            if (transitions.length === 0) return;

            // Update current index
            selectedSignal.currentIndex = findCurrentTransitionIndex(transitions, globalCursorTime);
            
            // Move to previous transition
            const newIndex = Math.max(0, selectedSignal.currentIndex - 1);
            selectedSignal.currentIndex = newIndex;
            const previousTime = transitions[newIndex];
            
            const width = document.querySelector('canvas').width;
            const cursorX = ((previousTime - globalStartTime) / (globalEndTime - globalStartTime)) * width;
            updateCursor(cursorX);
        }

        function moveToNextTransition() {
            if (!selectedSignal) return;
            
            const transitions = selectedSignal.transitions;
            if (transitions.length === 0) return;

            // Update current index
            selectedSignal.currentIndex = findCurrentTransitionIndex(transitions, globalCursorTime);
            
            // Move to next transition
            const newIndex = Math.min(transitions.length - 1, selectedSignal.currentIndex + 1);
            selectedSignal.currentIndex = newIndex;
            const nextTime = transitions[newIndex];
            
            const width = document.querySelector('canvas').width;
            const cursorX = ((nextTime - globalStartTime) / (globalEndTime - globalStartTime)) * width;
            updateCursor(cursorX);
        }
    </script>
    <style>
        #signals .header, #signals .row {
            display: grid;
            grid-template-columns: 300px 1fr;
            padding: 5px;
            align-items: center;
        }
        #signals .header {
            font-weight: bold;
            border-bottom: 1px solid #ccc;
            margin-bottom: 10px;
        }
        .waveform-header {
            display: flex;
            align-items: center;
        }
        canvas {
            border: 1px solid #ccc;
            background: white;
        }
        canvas.selected {
            border: 2px solid #0066cc;
        }
        .signal-name {
            cursor: pointer;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }
        .signal-name:hover {
            background-color: #f0f0f0;
        }
        .signal-name.selected {
            background-color: #e6f0ff;
            color: #0066cc;
            font-weight: bold;
        }
        #cursor-time {
            margin: 10px 0;
            font-weight: bold;
            color: #666;
        }
        #cursor-controls {
            margin: 10px 0;
            display: flex;
            gap: 10px;
        }
        #cursor-controls button {
            padding: 5px 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <form id="upload-form" onsubmit="return uploadVCD()">
        {% csrf_token %}
        <input type="file" name="vcd_file" accept=".vcd" required>
        <button type="submit">Upload VCD File</button>
    </form>
    <div id="status"></div>
    <div id="signals">
        <div id="cursor-time">Cursor Time: 0</div>
        <div id="cursor-controls">
            <button onclick="moveCursorToStart()">⏮ Start</button>
            <button onclick="moveToPreviousTransition()">◀ Prev</button>
            <button onclick="moveToNextTransition()">Next ▶</button>
            <button onclick="moveCursorToEnd()">End ⏭</button>
        </div>
        <div class="header">
            <div>Signals</div>
            <div class="waveform-header">
                <canvas id="timeline" width="800" height="30"></canvas>
            </div>
        </div>
    </div>
</body>
</html> 